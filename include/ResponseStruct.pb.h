// Generated by the protocol buffer compiler.  DO NOT EDIT!
// NO CHECKED-IN PROTOBUF GENCODE
// source: ResponseStruct.proto
// Protobuf C++ Version: 6.32.0-dev

#ifndef ResponseStruct_2eproto_2epb_2eh
#define ResponseStruct_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>
#include <utility>

#include "google/protobuf/runtime_version.h"
#if PROTOBUF_VERSION != 6032000
#error "Protobuf C++ gencode is built with an incompatible version of"
#error "Protobuf C++ headers/runtime. See"
#error "https://protobuf.dev/support/cross-version-runtime-guarantee/#cpp"
#endif
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/message_lite.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/generated_enum_reflection.h"
#include "google/protobuf/unknown_field_set.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_ResponseStruct_2eproto

namespace google {
namespace protobuf {
namespace internal {
template <typename T>
::absl::string_view GetAnyMessageName();
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct TableStruct_ResponseStruct_2eproto {
  static const ::uint32_t offsets[];
};
extern "C" {
extern const ::google::protobuf::internal::DescriptorTable descriptor_table_ResponseStruct_2eproto;
}  // extern "C"
namespace ResponseStruct {
enum ResponseInfo_responseTypes : int;
extern const uint32_t ResponseInfo_responseTypes_internal_data_[];
class DirInfo;
struct DirInfoDefaultTypeInternal;
extern DirInfoDefaultTypeInternal _DirInfo_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull DirInfo_class_data_;
class FileInfo;
struct FileInfoDefaultTypeInternal;
extern FileInfoDefaultTypeInternal _FileInfo_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull FileInfo_class_data_;
class NameOfMainExeFile;
struct NameOfMainExeFileDefaultTypeInternal;
extern NameOfMainExeFileDefaultTypeInternal _NameOfMainExeFile_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull NameOfMainExeFile_class_data_;
class Response;
struct ResponseDefaultTypeInternal;
extern ResponseDefaultTypeInternal _Response_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull Response_class_data_;
class ResponseInfo;
struct ResponseInfoDefaultTypeInternal;
extern ResponseInfoDefaultTypeInternal _ResponseInfo_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull ResponseInfo_class_data_;
}  // namespace ResponseStruct
namespace google {
namespace protobuf {
template <>
internal::EnumTraitsT<::ResponseStruct::ResponseInfo_responseTypes_internal_data_>
    internal::EnumTraitsImpl::value<::ResponseStruct::ResponseInfo_responseTypes>;
}  // namespace protobuf
}  // namespace google

namespace ResponseStruct {
enum ResponseInfo_responseTypes : int {
  ResponseInfo_responseTypes_unknown = 0,
  ResponseInfo_responseTypes_filesHashes = 1,
  ResponseInfo_responseTypes_downloadFile = 2,
  ResponseInfo_responseTypes_ResponseInfo_responseTypes_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::min(),
  ResponseInfo_responseTypes_ResponseInfo_responseTypes_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t ResponseInfo_responseTypes_internal_data_[];
inline constexpr ResponseInfo_responseTypes ResponseInfo_responseTypes_responseTypes_MIN =
    static_cast<ResponseInfo_responseTypes>(0);
inline constexpr ResponseInfo_responseTypes ResponseInfo_responseTypes_responseTypes_MAX =
    static_cast<ResponseInfo_responseTypes>(2);
inline bool ResponseInfo_responseTypes_IsValid(int value) {
  return 0 <= value && value <= 2;
}
inline constexpr int ResponseInfo_responseTypes_responseTypes_ARRAYSIZE = 2 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL ResponseInfo_responseTypes_descriptor();
template <typename T>
const ::std::string& ResponseInfo_responseTypes_Name(T value) {
  static_assert(::std::is_same<T, ResponseInfo_responseTypes>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to responseTypes_Name().");
  return ResponseInfo_responseTypes_Name(static_cast<ResponseInfo_responseTypes>(value));
}
template <>
inline const ::std::string& ResponseInfo_responseTypes_Name(ResponseInfo_responseTypes value) {
  return ::google::protobuf::internal::NameOfDenseEnum<ResponseInfo_responseTypes_descriptor, 0, 2>(
      static_cast<int>(value));
}
inline bool ResponseInfo_responseTypes_Parse(
    ::absl::string_view name, ResponseInfo_responseTypes* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<ResponseInfo_responseTypes>(ResponseInfo_responseTypes_descriptor(), name,
                                           value);
}

// ===================================================================


// -------------------------------------------------------------------

class ResponseInfo final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:ResponseStruct.ResponseInfo) */ {
 public:
  inline ResponseInfo() : ResponseInfo(nullptr) {}
  ~ResponseInfo() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ResponseInfo* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ResponseInfo));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ResponseInfo(::google::protobuf::internal::ConstantInitialized);

  inline ResponseInfo(const ResponseInfo& from) : ResponseInfo(nullptr, from) {}
  inline ResponseInfo(ResponseInfo&& from) noexcept
      : ResponseInfo(nullptr, ::std::move(from)) {}
  inline ResponseInfo& operator=(const ResponseInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline ResponseInfo& operator=(ResponseInfo&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ResponseInfo& default_instance() {
    return *reinterpret_cast<const ResponseInfo*>(
        &_ResponseInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 3;
  friend void swap(ResponseInfo& a, ResponseInfo& b) { a.Swap(&b); }
  inline void Swap(ResponseInfo* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ResponseInfo* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ResponseInfo* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<ResponseInfo>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ResponseInfo& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ResponseInfo& from) { ResponseInfo::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(ResponseInfo* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "ResponseStruct.ResponseInfo"; }

 protected:
  explicit ResponseInfo(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  ResponseInfo(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const ResponseInfo& from);
  ResponseInfo(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, ResponseInfo&& from) noexcept
      : ResponseInfo(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------
  using responseTypes = ResponseInfo_responseTypes;
  static constexpr responseTypes unknown = ResponseInfo_responseTypes_unknown;
  static constexpr responseTypes filesHashes = ResponseInfo_responseTypes_filesHashes;
  static constexpr responseTypes downloadFile = ResponseInfo_responseTypes_downloadFile;
  static inline bool responseTypes_IsValid(int value) {
    return ResponseInfo_responseTypes_IsValid(value);
  }
  static constexpr responseTypes responseTypes_MIN = ResponseInfo_responseTypes_responseTypes_MIN;
  static constexpr responseTypes responseTypes_MAX = ResponseInfo_responseTypes_responseTypes_MAX;
  static constexpr int responseTypes_ARRAYSIZE = ResponseInfo_responseTypes_responseTypes_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL responseTypes_descriptor() {
    return ResponseInfo_responseTypes_descriptor();
  }
  template <typename T>
  static inline const ::std::string& responseTypes_Name(T value) {
    return ResponseInfo_responseTypes_Name(value);
  }
  static inline bool responseTypes_Parse(
      ::absl::string_view name, responseTypes* PROTOBUF_NONNULL value) {
    return ResponseInfo_responseTypes_Parse(name, value);
  }

  // accessors -------------------------------------------------------
  enum : int {
    kTypeFieldNumber = 1,
  };
  // .ResponseStruct.ResponseInfo.responseTypes type = 1;
  void clear_type() ;
  ::ResponseStruct::ResponseInfo_responseTypes type() const;
  void set_type(::ResponseStruct::ResponseInfo_responseTypes value);

  private:
  ::ResponseStruct::ResponseInfo_responseTypes _internal_type() const;
  void _internal_set_type(::ResponseStruct::ResponseInfo_responseTypes value);

  public:
  // @@protoc_insertion_point(class_scope:ResponseStruct.ResponseInfo)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1,
                                   0, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const ResponseInfo& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    int type_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ResponseStruct_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull ResponseInfo_class_data_;
// -------------------------------------------------------------------

class NameOfMainExeFile final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:ResponseStruct.NameOfMainExeFile) */ {
 public:
  inline NameOfMainExeFile() : NameOfMainExeFile(nullptr) {}
  ~NameOfMainExeFile() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(NameOfMainExeFile* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(NameOfMainExeFile));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR NameOfMainExeFile(::google::protobuf::internal::ConstantInitialized);

  inline NameOfMainExeFile(const NameOfMainExeFile& from) : NameOfMainExeFile(nullptr, from) {}
  inline NameOfMainExeFile(NameOfMainExeFile&& from) noexcept
      : NameOfMainExeFile(nullptr, ::std::move(from)) {}
  inline NameOfMainExeFile& operator=(const NameOfMainExeFile& from) {
    CopyFrom(from);
    return *this;
  }
  inline NameOfMainExeFile& operator=(NameOfMainExeFile&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NameOfMainExeFile& default_instance() {
    return *reinterpret_cast<const NameOfMainExeFile*>(
        &_NameOfMainExeFile_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 2;
  friend void swap(NameOfMainExeFile& a, NameOfMainExeFile& b) { a.Swap(&b); }
  inline void Swap(NameOfMainExeFile* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NameOfMainExeFile* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NameOfMainExeFile* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<NameOfMainExeFile>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const NameOfMainExeFile& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const NameOfMainExeFile& from) { NameOfMainExeFile::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(NameOfMainExeFile* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "ResponseStruct.NameOfMainExeFile"; }

 protected:
  explicit NameOfMainExeFile(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  NameOfMainExeFile(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const NameOfMainExeFile& from);
  NameOfMainExeFile(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, NameOfMainExeFile&& from) noexcept
      : NameOfMainExeFile(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kNameFieldNumber = 1,
  };
  // string name = 1;
  void clear_name() ;
  const ::std::string& name() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_name();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_name();
  void set_allocated_name(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_name() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_name(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_name();

  public:
  // @@protoc_insertion_point(class_scope:ResponseStruct.NameOfMainExeFile)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1,
                                   0, 45,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const NameOfMainExeFile& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr name_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ResponseStruct_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull NameOfMainExeFile_class_data_;
// -------------------------------------------------------------------

class FileInfo final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:ResponseStruct.FileInfo) */ {
 public:
  inline FileInfo() : FileInfo(nullptr) {}
  ~FileInfo() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(FileInfo* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(FileInfo));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR FileInfo(::google::protobuf::internal::ConstantInitialized);

  inline FileInfo(const FileInfo& from) : FileInfo(nullptr, from) {}
  inline FileInfo(FileInfo&& from) noexcept
      : FileInfo(nullptr, ::std::move(from)) {}
  inline FileInfo& operator=(const FileInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline FileInfo& operator=(FileInfo&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FileInfo& default_instance() {
    return *reinterpret_cast<const FileInfo*>(
        &_FileInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 0;
  friend void swap(FileInfo& a, FileInfo& b) { a.Swap(&b); }
  inline void Swap(FileInfo* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FileInfo* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FileInfo* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<FileInfo>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const FileInfo& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const FileInfo& from) { FileInfo::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(FileInfo* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "ResponseStruct.FileInfo"; }

 protected:
  explicit FileInfo(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  FileInfo(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const FileInfo& from);
  FileInfo(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, FileInfo&& from) noexcept
      : FileInfo(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kNameFieldNumber = 1,
    kPathFieldNumber = 2,
    kHashFieldNumber = 3,
  };
  // string name = 1;
  void clear_name() ;
  const ::std::string& name() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_name();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_name();
  void set_allocated_name(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_name() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_name(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_name();

  public:
  // string path = 2;
  void clear_path() ;
  const ::std::string& path() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_path(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_path();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_path();
  void set_allocated_path(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_path() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_path(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_path();

  public:
  // string hash = 3;
  void clear_hash() ;
  const ::std::string& hash() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_hash(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_hash();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_hash();
  void set_allocated_hash(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_hash() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_hash(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_hash();

  public:
  // @@protoc_insertion_point(class_scope:ResponseStruct.FileInfo)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 3,
                                   0, 44,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const FileInfo& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr name_;
    ::google::protobuf::internal::ArenaStringPtr path_;
    ::google::protobuf::internal::ArenaStringPtr hash_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ResponseStruct_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull FileInfo_class_data_;
// -------------------------------------------------------------------

class DirInfo final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:ResponseStruct.DirInfo) */ {
 public:
  inline DirInfo() : DirInfo(nullptr) {}
  ~DirInfo() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(DirInfo* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(DirInfo));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR DirInfo(::google::protobuf::internal::ConstantInitialized);

  inline DirInfo(const DirInfo& from) : DirInfo(nullptr, from) {}
  inline DirInfo(DirInfo&& from) noexcept
      : DirInfo(nullptr, ::std::move(from)) {}
  inline DirInfo& operator=(const DirInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline DirInfo& operator=(DirInfo&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DirInfo& default_instance() {
    return *reinterpret_cast<const DirInfo*>(
        &_DirInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 1;
  friend void swap(DirInfo& a, DirInfo& b) { a.Swap(&b); }
  inline void Swap(DirInfo* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DirInfo* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DirInfo* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<DirInfo>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const DirInfo& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const DirInfo& from) { DirInfo::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(DirInfo* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "ResponseStruct.DirInfo"; }

 protected:
  explicit DirInfo(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  DirInfo(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const DirInfo& from);
  DirInfo(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, DirInfo&& from) noexcept
      : DirInfo(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kPathFieldNumber = 1,
  };
  // string path = 1;
  void clear_path() ;
  const ::std::string& path() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_path(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_path();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_path();
  void set_allocated_path(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_path() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_path(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_path();

  public:
  // @@protoc_insertion_point(class_scope:ResponseStruct.DirInfo)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1,
                                   0, 35,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const DirInfo& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr path_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ResponseStruct_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull DirInfo_class_data_;
// -------------------------------------------------------------------

class Response final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:ResponseStruct.Response) */ {
 public:
  inline Response() : Response(nullptr) {}
  ~Response() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(Response* PROTOBUF_NONNULL msg, ::std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(Response));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Response(::google::protobuf::internal::ConstantInitialized);

  inline Response(const Response& from) : Response(nullptr, from) {}
  inline Response(Response&& from) noexcept
      : Response(nullptr, ::std::move(from)) {}
  inline Response& operator=(const Response& from) {
    CopyFrom(from);
    return *this;
  }
  inline Response& operator=(Response&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Response& default_instance() {
    return *reinterpret_cast<const Response*>(
        &_Response_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 4;
  friend void swap(Response& a, Response& b) { a.Swap(&b); }
  inline void Swap(Response* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Response* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Response* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<Response>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Response& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Response& from) { Response::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(Response* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "ResponseStruct.Response"; }

 protected:
  explicit Response(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  Response(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Response& from);
  Response(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, Response&& from) noexcept
      : Response(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kFileInfoFieldNumber = 2,
    kDirInfoFieldNumber = 3,
    kResponseInfoFieldNumber = 1,
    kNameOfMainExeFileFieldNumber = 4,
  };
  // repeated .ResponseStruct.FileInfo fileInfo = 2;
  int fileinfo_size() const;
  private:
  int _internal_fileinfo_size() const;

  public:
  void clear_fileinfo() ;
  ::ResponseStruct::FileInfo* PROTOBUF_NONNULL mutable_fileinfo(int index);
  ::google::protobuf::RepeatedPtrField<::ResponseStruct::FileInfo>* PROTOBUF_NONNULL mutable_fileinfo();

  private:
  const ::google::protobuf::RepeatedPtrField<::ResponseStruct::FileInfo>& _internal_fileinfo() const;
  ::google::protobuf::RepeatedPtrField<::ResponseStruct::FileInfo>* PROTOBUF_NONNULL _internal_mutable_fileinfo();
  public:
  const ::ResponseStruct::FileInfo& fileinfo(int index) const;
  ::ResponseStruct::FileInfo* PROTOBUF_NONNULL add_fileinfo();
  const ::google::protobuf::RepeatedPtrField<::ResponseStruct::FileInfo>& fileinfo() const;
  // repeated .ResponseStruct.DirInfo dirInfo = 3;
  int dirinfo_size() const;
  private:
  int _internal_dirinfo_size() const;

  public:
  void clear_dirinfo() ;
  ::ResponseStruct::DirInfo* PROTOBUF_NONNULL mutable_dirinfo(int index);
  ::google::protobuf::RepeatedPtrField<::ResponseStruct::DirInfo>* PROTOBUF_NONNULL mutable_dirinfo();

  private:
  const ::google::protobuf::RepeatedPtrField<::ResponseStruct::DirInfo>& _internal_dirinfo() const;
  ::google::protobuf::RepeatedPtrField<::ResponseStruct::DirInfo>* PROTOBUF_NONNULL _internal_mutable_dirinfo();
  public:
  const ::ResponseStruct::DirInfo& dirinfo(int index) const;
  ::ResponseStruct::DirInfo* PROTOBUF_NONNULL add_dirinfo();
  const ::google::protobuf::RepeatedPtrField<::ResponseStruct::DirInfo>& dirinfo() const;
  // .ResponseStruct.ResponseInfo responseInfo = 1;
  bool has_responseinfo() const;
  void clear_responseinfo() ;
  const ::ResponseStruct::ResponseInfo& responseinfo() const;
  [[nodiscard]] ::ResponseStruct::ResponseInfo* PROTOBUF_NULLABLE release_responseinfo();
  ::ResponseStruct::ResponseInfo* PROTOBUF_NONNULL mutable_responseinfo();
  void set_allocated_responseinfo(::ResponseStruct::ResponseInfo* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_responseinfo(::ResponseStruct::ResponseInfo* PROTOBUF_NULLABLE value);
  ::ResponseStruct::ResponseInfo* PROTOBUF_NULLABLE unsafe_arena_release_responseinfo();

  private:
  const ::ResponseStruct::ResponseInfo& _internal_responseinfo() const;
  ::ResponseStruct::ResponseInfo* PROTOBUF_NONNULL _internal_mutable_responseinfo();

  public:
  // .ResponseStruct.NameOfMainExeFile nameOfMainExeFile = 4;
  bool has_nameofmainexefile() const;
  void clear_nameofmainexefile() ;
  const ::ResponseStruct::NameOfMainExeFile& nameofmainexefile() const;
  [[nodiscard]] ::ResponseStruct::NameOfMainExeFile* PROTOBUF_NULLABLE release_nameofmainexefile();
  ::ResponseStruct::NameOfMainExeFile* PROTOBUF_NONNULL mutable_nameofmainexefile();
  void set_allocated_nameofmainexefile(::ResponseStruct::NameOfMainExeFile* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_nameofmainexefile(::ResponseStruct::NameOfMainExeFile* PROTOBUF_NULLABLE value);
  ::ResponseStruct::NameOfMainExeFile* PROTOBUF_NULLABLE unsafe_arena_release_nameofmainexefile();

  private:
  const ::ResponseStruct::NameOfMainExeFile& _internal_nameofmainexefile() const;
  ::ResponseStruct::NameOfMainExeFile* PROTOBUF_NONNULL _internal_mutable_nameofmainexefile();

  public:
  // @@protoc_insertion_point(class_scope:ResponseStruct.Response)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 4,
                                   4, 0,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const Response& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::ResponseStruct::FileInfo > fileinfo_;
    ::google::protobuf::RepeatedPtrField< ::ResponseStruct::DirInfo > dirinfo_;
    ::ResponseStruct::ResponseInfo* PROTOBUF_NULLABLE responseinfo_;
    ::ResponseStruct::NameOfMainExeFile* PROTOBUF_NULLABLE nameofmainexefile_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ResponseStruct_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull Response_class_data_;

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// FileInfo

// string name = 1;
inline void FileInfo::clear_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001U;
}
inline const ::std::string& FileInfo::name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ResponseStruct.FileInfo.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void FileInfo::set_name(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001U;
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:ResponseStruct.FileInfo.name)
}
inline ::std::string* PROTOBUF_NONNULL FileInfo::mutable_name()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:ResponseStruct.FileInfo.name)
  return _s;
}
inline const ::std::string& FileInfo::_internal_name() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.name_.Get();
}
inline void FileInfo::_internal_set_name(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001U;
  _impl_.name_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL FileInfo::_internal_mutable_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001U;
  return _impl_.name_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE FileInfo::release_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:ResponseStruct.FileInfo.name)
  if ((_impl_._has_bits_[0] & 0x00000001U) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001U;
  auto* released = _impl_.name_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.name_.Set("", GetArena());
  }
  return released;
}
inline void FileInfo::set_allocated_name(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001U;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001U;
  }
  _impl_.name_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:ResponseStruct.FileInfo.name)
}

// string path = 2;
inline void FileInfo::clear_path() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.path_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002U;
}
inline const ::std::string& FileInfo::path() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ResponseStruct.FileInfo.path)
  return _internal_path();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void FileInfo::set_path(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002U;
  _impl_.path_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:ResponseStruct.FileInfo.path)
}
inline ::std::string* PROTOBUF_NONNULL FileInfo::mutable_path()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::std::string* _s = _internal_mutable_path();
  // @@protoc_insertion_point(field_mutable:ResponseStruct.FileInfo.path)
  return _s;
}
inline const ::std::string& FileInfo::_internal_path() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.path_.Get();
}
inline void FileInfo::_internal_set_path(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002U;
  _impl_.path_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL FileInfo::_internal_mutable_path() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002U;
  return _impl_.path_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE FileInfo::release_path() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:ResponseStruct.FileInfo.path)
  if ((_impl_._has_bits_[0] & 0x00000002U) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002U;
  auto* released = _impl_.path_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.path_.Set("", GetArena());
  }
  return released;
}
inline void FileInfo::set_allocated_path(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002U;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002U;
  }
  _impl_.path_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.path_.IsDefault()) {
    _impl_.path_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:ResponseStruct.FileInfo.path)
}

// string hash = 3;
inline void FileInfo::clear_hash() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.hash_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004U;
}
inline const ::std::string& FileInfo::hash() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ResponseStruct.FileInfo.hash)
  return _internal_hash();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void FileInfo::set_hash(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000004U;
  _impl_.hash_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:ResponseStruct.FileInfo.hash)
}
inline ::std::string* PROTOBUF_NONNULL FileInfo::mutable_hash()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::std::string* _s = _internal_mutable_hash();
  // @@protoc_insertion_point(field_mutable:ResponseStruct.FileInfo.hash)
  return _s;
}
inline const ::std::string& FileInfo::_internal_hash() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.hash_.Get();
}
inline void FileInfo::_internal_set_hash(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000004U;
  _impl_.hash_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL FileInfo::_internal_mutable_hash() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000004U;
  return _impl_.hash_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE FileInfo::release_hash() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:ResponseStruct.FileInfo.hash)
  if ((_impl_._has_bits_[0] & 0x00000004U) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004U;
  auto* released = _impl_.hash_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.hash_.Set("", GetArena());
  }
  return released;
}
inline void FileInfo::set_allocated_hash(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004U;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004U;
  }
  _impl_.hash_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.hash_.IsDefault()) {
    _impl_.hash_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:ResponseStruct.FileInfo.hash)
}

// -------------------------------------------------------------------

// DirInfo

// string path = 1;
inline void DirInfo::clear_path() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.path_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001U;
}
inline const ::std::string& DirInfo::path() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ResponseStruct.DirInfo.path)
  return _internal_path();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void DirInfo::set_path(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001U;
  _impl_.path_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:ResponseStruct.DirInfo.path)
}
inline ::std::string* PROTOBUF_NONNULL DirInfo::mutable_path()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::std::string* _s = _internal_mutable_path();
  // @@protoc_insertion_point(field_mutable:ResponseStruct.DirInfo.path)
  return _s;
}
inline const ::std::string& DirInfo::_internal_path() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.path_.Get();
}
inline void DirInfo::_internal_set_path(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001U;
  _impl_.path_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL DirInfo::_internal_mutable_path() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001U;
  return _impl_.path_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE DirInfo::release_path() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:ResponseStruct.DirInfo.path)
  if ((_impl_._has_bits_[0] & 0x00000001U) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001U;
  auto* released = _impl_.path_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.path_.Set("", GetArena());
  }
  return released;
}
inline void DirInfo::set_allocated_path(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001U;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001U;
  }
  _impl_.path_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.path_.IsDefault()) {
    _impl_.path_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:ResponseStruct.DirInfo.path)
}

// -------------------------------------------------------------------

// NameOfMainExeFile

// string name = 1;
inline void NameOfMainExeFile::clear_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001U;
}
inline const ::std::string& NameOfMainExeFile::name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ResponseStruct.NameOfMainExeFile.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void NameOfMainExeFile::set_name(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001U;
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:ResponseStruct.NameOfMainExeFile.name)
}
inline ::std::string* PROTOBUF_NONNULL NameOfMainExeFile::mutable_name()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:ResponseStruct.NameOfMainExeFile.name)
  return _s;
}
inline const ::std::string& NameOfMainExeFile::_internal_name() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.name_.Get();
}
inline void NameOfMainExeFile::_internal_set_name(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001U;
  _impl_.name_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL NameOfMainExeFile::_internal_mutable_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001U;
  return _impl_.name_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE NameOfMainExeFile::release_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:ResponseStruct.NameOfMainExeFile.name)
  if ((_impl_._has_bits_[0] & 0x00000001U) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001U;
  auto* released = _impl_.name_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.name_.Set("", GetArena());
  }
  return released;
}
inline void NameOfMainExeFile::set_allocated_name(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001U;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001U;
  }
  _impl_.name_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:ResponseStruct.NameOfMainExeFile.name)
}

// -------------------------------------------------------------------

// ResponseInfo

// .ResponseStruct.ResponseInfo.responseTypes type = 1;
inline void ResponseInfo::clear_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.type_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001U;
}
inline ::ResponseStruct::ResponseInfo_responseTypes ResponseInfo::type() const {
  // @@protoc_insertion_point(field_get:ResponseStruct.ResponseInfo.type)
  return _internal_type();
}
inline void ResponseInfo::set_type(::ResponseStruct::ResponseInfo_responseTypes value) {
  _internal_set_type(value);
  _impl_._has_bits_[0] |= 0x00000001U;
  // @@protoc_insertion_point(field_set:ResponseStruct.ResponseInfo.type)
}
inline ::ResponseStruct::ResponseInfo_responseTypes ResponseInfo::_internal_type() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::ResponseStruct::ResponseInfo_responseTypes>(_impl_.type_);
}
inline void ResponseInfo::_internal_set_type(::ResponseStruct::ResponseInfo_responseTypes value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.type_ = value;
}

// -------------------------------------------------------------------

// Response

// .ResponseStruct.ResponseInfo responseInfo = 1;
inline bool Response::has_responseinfo() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001U) != 0;
  PROTOBUF_ASSUME(!value || _impl_.responseinfo_ != nullptr);
  return value;
}
inline void Response::clear_responseinfo() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.responseinfo_ != nullptr) _impl_.responseinfo_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001U;
}
inline const ::ResponseStruct::ResponseInfo& Response::_internal_responseinfo() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::ResponseStruct::ResponseInfo* p = _impl_.responseinfo_;
  return p != nullptr ? *p : reinterpret_cast<const ::ResponseStruct::ResponseInfo&>(::ResponseStruct::_ResponseInfo_default_instance_);
}
inline const ::ResponseStruct::ResponseInfo& Response::responseinfo() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ResponseStruct.Response.responseInfo)
  return _internal_responseinfo();
}
inline void Response::unsafe_arena_set_allocated_responseinfo(
    ::ResponseStruct::ResponseInfo* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.responseinfo_);
  }
  _impl_.responseinfo_ = reinterpret_cast<::ResponseStruct::ResponseInfo*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001U;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001U;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ResponseStruct.Response.responseInfo)
}
inline ::ResponseStruct::ResponseInfo* PROTOBUF_NULLABLE Response::release_responseinfo() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001U;
  ::ResponseStruct::ResponseInfo* released = _impl_.responseinfo_;
  _impl_.responseinfo_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::ResponseStruct::ResponseInfo* PROTOBUF_NULLABLE Response::unsafe_arena_release_responseinfo() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:ResponseStruct.Response.responseInfo)

  _impl_._has_bits_[0] &= ~0x00000001U;
  ::ResponseStruct::ResponseInfo* temp = _impl_.responseinfo_;
  _impl_.responseinfo_ = nullptr;
  return temp;
}
inline ::ResponseStruct::ResponseInfo* PROTOBUF_NONNULL Response::_internal_mutable_responseinfo() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.responseinfo_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::ResponseStruct::ResponseInfo>(GetArena());
    _impl_.responseinfo_ = reinterpret_cast<::ResponseStruct::ResponseInfo*>(p);
  }
  return _impl_.responseinfo_;
}
inline ::ResponseStruct::ResponseInfo* PROTOBUF_NONNULL Response::mutable_responseinfo()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001U;
  ::ResponseStruct::ResponseInfo* _msg = _internal_mutable_responseinfo();
  // @@protoc_insertion_point(field_mutable:ResponseStruct.Response.responseInfo)
  return _msg;
}
inline void Response::set_allocated_responseinfo(::ResponseStruct::ResponseInfo* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.responseinfo_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001U;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001U;
  }

  _impl_.responseinfo_ = reinterpret_cast<::ResponseStruct::ResponseInfo*>(value);
  // @@protoc_insertion_point(field_set_allocated:ResponseStruct.Response.responseInfo)
}

// repeated .ResponseStruct.FileInfo fileInfo = 2;
inline int Response::_internal_fileinfo_size() const {
  return _internal_fileinfo().size();
}
inline int Response::fileinfo_size() const {
  return _internal_fileinfo_size();
}
inline void Response::clear_fileinfo() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.fileinfo_.Clear();
}
inline ::ResponseStruct::FileInfo* PROTOBUF_NONNULL Response::mutable_fileinfo(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:ResponseStruct.Response.fileInfo)
  return _internal_mutable_fileinfo()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::ResponseStruct::FileInfo>* PROTOBUF_NONNULL Response::mutable_fileinfo()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:ResponseStruct.Response.fileInfo)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_fileinfo();
}
inline const ::ResponseStruct::FileInfo& Response::fileinfo(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ResponseStruct.Response.fileInfo)
  return _internal_fileinfo().Get(index);
}
inline ::ResponseStruct::FileInfo* PROTOBUF_NONNULL Response::add_fileinfo()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::ResponseStruct::FileInfo* _add = _internal_mutable_fileinfo()->Add();
  // @@protoc_insertion_point(field_add:ResponseStruct.Response.fileInfo)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::ResponseStruct::FileInfo>& Response::fileinfo() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:ResponseStruct.Response.fileInfo)
  return _internal_fileinfo();
}
inline const ::google::protobuf::RepeatedPtrField<::ResponseStruct::FileInfo>&
Response::_internal_fileinfo() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.fileinfo_;
}
inline ::google::protobuf::RepeatedPtrField<::ResponseStruct::FileInfo>* PROTOBUF_NONNULL
Response::_internal_mutable_fileinfo() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.fileinfo_;
}

// repeated .ResponseStruct.DirInfo dirInfo = 3;
inline int Response::_internal_dirinfo_size() const {
  return _internal_dirinfo().size();
}
inline int Response::dirinfo_size() const {
  return _internal_dirinfo_size();
}
inline void Response::clear_dirinfo() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.dirinfo_.Clear();
}
inline ::ResponseStruct::DirInfo* PROTOBUF_NONNULL Response::mutable_dirinfo(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:ResponseStruct.Response.dirInfo)
  return _internal_mutable_dirinfo()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::ResponseStruct::DirInfo>* PROTOBUF_NONNULL Response::mutable_dirinfo()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:ResponseStruct.Response.dirInfo)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_dirinfo();
}
inline const ::ResponseStruct::DirInfo& Response::dirinfo(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ResponseStruct.Response.dirInfo)
  return _internal_dirinfo().Get(index);
}
inline ::ResponseStruct::DirInfo* PROTOBUF_NONNULL Response::add_dirinfo()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::ResponseStruct::DirInfo* _add = _internal_mutable_dirinfo()->Add();
  // @@protoc_insertion_point(field_add:ResponseStruct.Response.dirInfo)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::ResponseStruct::DirInfo>& Response::dirinfo() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:ResponseStruct.Response.dirInfo)
  return _internal_dirinfo();
}
inline const ::google::protobuf::RepeatedPtrField<::ResponseStruct::DirInfo>&
Response::_internal_dirinfo() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.dirinfo_;
}
inline ::google::protobuf::RepeatedPtrField<::ResponseStruct::DirInfo>* PROTOBUF_NONNULL
Response::_internal_mutable_dirinfo() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.dirinfo_;
}

// .ResponseStruct.NameOfMainExeFile nameOfMainExeFile = 4;
inline bool Response::has_nameofmainexefile() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002U) != 0;
  PROTOBUF_ASSUME(!value || _impl_.nameofmainexefile_ != nullptr);
  return value;
}
inline void Response::clear_nameofmainexefile() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.nameofmainexefile_ != nullptr) _impl_.nameofmainexefile_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002U;
}
inline const ::ResponseStruct::NameOfMainExeFile& Response::_internal_nameofmainexefile() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::ResponseStruct::NameOfMainExeFile* p = _impl_.nameofmainexefile_;
  return p != nullptr ? *p : reinterpret_cast<const ::ResponseStruct::NameOfMainExeFile&>(::ResponseStruct::_NameOfMainExeFile_default_instance_);
}
inline const ::ResponseStruct::NameOfMainExeFile& Response::nameofmainexefile() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ResponseStruct.Response.nameOfMainExeFile)
  return _internal_nameofmainexefile();
}
inline void Response::unsafe_arena_set_allocated_nameofmainexefile(
    ::ResponseStruct::NameOfMainExeFile* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.nameofmainexefile_);
  }
  _impl_.nameofmainexefile_ = reinterpret_cast<::ResponseStruct::NameOfMainExeFile*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002U;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002U;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ResponseStruct.Response.nameOfMainExeFile)
}
inline ::ResponseStruct::NameOfMainExeFile* PROTOBUF_NULLABLE Response::release_nameofmainexefile() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002U;
  ::ResponseStruct::NameOfMainExeFile* released = _impl_.nameofmainexefile_;
  _impl_.nameofmainexefile_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::ResponseStruct::NameOfMainExeFile* PROTOBUF_NULLABLE Response::unsafe_arena_release_nameofmainexefile() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:ResponseStruct.Response.nameOfMainExeFile)

  _impl_._has_bits_[0] &= ~0x00000002U;
  ::ResponseStruct::NameOfMainExeFile* temp = _impl_.nameofmainexefile_;
  _impl_.nameofmainexefile_ = nullptr;
  return temp;
}
inline ::ResponseStruct::NameOfMainExeFile* PROTOBUF_NONNULL Response::_internal_mutable_nameofmainexefile() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.nameofmainexefile_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::ResponseStruct::NameOfMainExeFile>(GetArena());
    _impl_.nameofmainexefile_ = reinterpret_cast<::ResponseStruct::NameOfMainExeFile*>(p);
  }
  return _impl_.nameofmainexefile_;
}
inline ::ResponseStruct::NameOfMainExeFile* PROTOBUF_NONNULL Response::mutable_nameofmainexefile()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002U;
  ::ResponseStruct::NameOfMainExeFile* _msg = _internal_mutable_nameofmainexefile();
  // @@protoc_insertion_point(field_mutable:ResponseStruct.Response.nameOfMainExeFile)
  return _msg;
}
inline void Response::set_allocated_nameofmainexefile(::ResponseStruct::NameOfMainExeFile* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.nameofmainexefile_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002U;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002U;
  }

  _impl_.nameofmainexefile_ = reinterpret_cast<::ResponseStruct::NameOfMainExeFile*>(value);
  // @@protoc_insertion_point(field_set_allocated:ResponseStruct.Response.nameOfMainExeFile)
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace ResponseStruct


namespace google {
namespace protobuf {

template <>
struct is_proto_enum<::ResponseStruct::ResponseInfo_responseTypes> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::ResponseStruct::ResponseInfo_responseTypes>() {
  return ::ResponseStruct::ResponseInfo_responseTypes_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // ResponseStruct_2eproto_2epb_2eh
